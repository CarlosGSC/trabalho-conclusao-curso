%% Simulação de Posicionamento de um Robô Diferencial com Animação (Versão Corrigida)
% Este código simula e anima o movimento de um robô diferencial,
% garantindo que a legenda do gráfico seja exibida corretamente.

clear all;
close all;
clc;

%% 1. Parâmetros da Simulação e do Robô
Ts = 0.1; % Tempo de amostragem (s)
t_sim = 20; % Tempo total de simulação (s)
pose_inicial = [0; 0; 0]; % Posição inicial [x; y; theta]
pose_goal = [5; 5];      % Posição de destino [x; y]
Kp_linear = 0.5;
Kp_angular = 2.0;
v_max = 0.4;
w_max = pi/2;
dist_limite = 0.1; 

%% 2. Inicialização das Variáveis
pose_robo = pose_inicial;
hist_pose = zeros(3, t_sim/Ts);
hist_pose(:,1) = pose_robo;
t = 1;

%% 3. Configuração Inicial do Gráfico
figure;
hold on;
grid on;
axis equal;
axis([-1 6 -1 6]); 
xlabel('Posição X (m)');
ylabel('Posição Y (m)');
title('Simulação de Posicionamento de Robô Diferencial');

% --- MUDANÇA PRINCIPAL: Criar os objetos e a legenda ANTES do loop ---

% Plota os pontos inicial e final para obter os "handles" (identificadores)
h_inicial = plot(pose_inicial(1), pose_inicial(2), 'ro', 'MarkerSize', 10, 'LineWidth', 2);
h_goal = plot(pose_goal(1), pose_goal(2), 'gx', 'MarkerSize', 10, 'LineWidth', 2);

% Plota o primeiro ponto da trajetória para criar o objeto da linha
h_trajetoria = plot(pose_robo(1), pose_robo(2), 'b-', 'LineWidth', 1.5);

% Cria o objeto que representará o robô (patch)
escala_robo = 0.3;
ponta_frente = [pose_robo(1) + escala_robo * cos(pose_robo(3)), pose_robo(2) + escala_robo * sin(pose_robo(3))];
ponta_tras_dir = [pose_robo(1) - escala_robo * cos(pose_robo(3) + pi/4), pose_robo(2) - escala_robo * sin(pose_robo(3) + pi/4)];
ponta_tras_esq = [pose_robo(1) - escala_robo * cos(pose_robo(3) - pi/4), pose_robo(2) - escala_robo * sin(pose_robo(3) - pi/4)];
h_robo = patch([ponta_frente(1) ponta_tras_dir(1) ponta_tras_esq(1)], ...
               [ponta_frente(2) ponta_tras_dir(2) ponta_tras_esq(2)], 'r');

% Cria a legenda UMA VEZ, usando os handles dos objetos que queremos legendar
legend([h_inicial, h_goal, h_trajetoria], ...
       {'Posição Inicial', 'Ponto de Destino', 'Trajetória'}, ...
       'Location', 'northwest');


%% 4. Loop de Simulação
while(t*Ts < t_sim)
    dist_erro = sqrt((pose_goal(1) - pose_robo(1))^2 + (pose_goal(2) - pose_robo(2))^2);
    if dist_erro < dist_limite
        disp('Robô chegou ao destino!');
        break;
    end
    
    angulo_erro = atan2(pose_goal(2) - pose_robo(2), pose_goal(1) - pose_robo(1)) - pose_robo(3);
    angulo_erro = atan2(sin(angulo_erro), cos(angulo_erro));
    
    v = min(Kp_linear * dist_erro, v_max);
    w = max(min(Kp_angular * angulo_erro, w_max), -w_max);

    pose_robo(1) = pose_robo(1) + v * cos(pose_robo(3)) * Ts;
    pose_robo(2) = pose_robo(2) + v * sin(pose_robo(3)) * Ts;
    pose_robo(3) = atan2(sin(pose_robo(3) + w * Ts), cos(pose_robo(3) + w * Ts));
    
    t = t + 1;
    hist_pose(:,t) = pose_robo;
    
    %% 5. Atualização da Animação (usando "set")
    % Atualiza os dados da linha da trajetória
    set(h_trajetoria, 'XData', hist_pose(1,1:t), 'YData', hist_pose(2,1:t));
    
    % Recalcula os vértices do robô e atualiza o patch
    ponta_frente = [pose_robo(1) + escala_robo * cos(pose_robo(3)), pose_robo(2) + escala_robo * sin(pose_robo(3))];
    ponta_tras_dir = [pose_robo(1) - escala_robo * cos(pose_robo(3) + pi/4), pose_robo(2) - escala_robo * sin(pose_robo(3) + pi/4)];
    ponta_tras_esq = [pose_robo(1) - escala_robo * cos(pose_robo(3) - pi/4), pose_robo(2) - escala_robo * sin(pose_robo(3) - pi/4)];
    set(h_robo, 'XData', [ponta_frente(1) ponta_tras_dir(1) ponta_tras_esq(1)], ...
                'YData', [ponta_frente(2) ponta_tras_dir(2) ponta_tras_esq(2)]);

    % Força a atualização do gráfico
    drawnow;
end

hold off;